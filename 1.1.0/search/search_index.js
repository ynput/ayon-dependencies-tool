var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#addon-dependencies-distribution-tool","title":"Addon dependencies distribution tool","text":"<p>This tool is backend portion of Addon distribution of dependencies for AYON launcher.</p> <p>This collects info about all enabled addons on the AYON server based on bundle name, reads their pyproject.toml files, create one merged pyproject.toml (it tries to find common denominator for dependency version).</p> <p>Then it uses Poetry to create new venv, zips it and provides this to AYON server for distribution.</p> <p>It is expected to run on machine that has set reasonable development environment.</p> <p>Required environment variables: - AYON_SERVER_URL - AYON server url - AYON_API_KEY - AYON api key for service account</p> <p>For local development, use <code>.env</code> file. You can use <code>example_env</code> as base.</p> <p>The tool should ideally run automatically and listen for events on the Server OR could be run manually on machine(s).</p> <p>Entry point for manual triggering is <code>start.ps1</code> or <code>start.sh</code>.</p> <p>Implemented commands: - <code>install</code> - creates <code>./.venv</code> with requirements for this tool - <code>create</code> - runs main process to create new dependency package and uploads it. Expects argument with name of Bundle (eg. <code>./start create -b MyBundle</code>). For more information <code>./start create --help</code>. - <code>listen</code> - starts service connecting to AYON server and listening for events to trigger main process (TBD) - <code>list-bundles</code> - lists all bundles on AYON server</p> <p>TODO: - [ ] force to reuse python version from Installer (make <code>pyenv</code> required) - [ ] safe runtime dependencies     - dependencies and runtime dependencies are not validated against each other     - e.g. SomeModule==1.0.0 can be defined in dependencies and SomeModule&gt;=1.1.0 in runtime dependencies - [ ] skip dependency package creation if there are not any addons with dependencies - [ ] Provide dockerized AYON service manageable directly by ASH (AYON service host) - [X] Provide single-time docker to create dependency packages for linux distros     - [X] be able to re-use the image for multiple runs     - [ ] take environment variables from called script     - [ ] limit which files are copied to docker (e.g. should not contain '.env' file)</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>dependencies<ul> <li>__main__</li> <li>_runtime_deps</li> <li>cli</li> <li>core</li> <li>custom_solver</li> <li>tests<ul> <li>test_dependencies</li> </ul> </li> <li>utils</li> </ul> </li> <li>server</li> <li>service<ul> <li>__main__</li> <li>listener</li> </ul> </li> </ul>"},{"location":"autoapi/dependencies/index.html","title":"dependencies","text":""},{"location":"autoapi/dependencies/index.html#dependencies.create_package","title":"<code>create_package(bundle_name, con=None, output_dir=None, skip_upload=False)</code>","text":"<p>Pulls all active addons info from server and create dependency package.</p> <ol> <li>Takes base (installer) pyproject.toml, and adds tomls from addons     pyproject.toml (if available).</li> <li>Builds new venv with dependencies only for addons (dependencies already     present in build are filtered out).</li> <li>Uploads zipped venv to server and set it to bundle.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>Name of bundle for which is package created.</p> required <code>con</code> <code>Optional[ServerAPI]</code> <p>Prepared server API object.</p> <code>None</code> <code>output_dir</code> <code>Optional[str]</code> <p>Path to directory where package will be created.</p> <code>None</code> <code>skip_upload</code> <code>Optional[bool]</code> <p>Skip upload to server. Default: False.</p> <code>False</code> Source code in <code>dependencies/core.py</code> <pre><code>def create_package(bundle_name, con=None, output_dir=None, skip_upload=False):\n    \"\"\"Pulls all active addons info from server and create dependency package.\n\n    1. Takes base (installer) pyproject.toml, and adds tomls from addons\n        pyproject.toml (if available).\n    2. Builds new venv with dependencies only for addons (dependencies already\n        present in build are filtered out).\n    3. Uploads zipped venv to server and set it to bundle.\n\n    Args:\n        bundle_name (str): Name of bundle for which is package created.\n        con (Optional[ayon_api.ServerAPI]): Prepared server API object.\n        output_dir (Optional[str]): Path to directory where package will be\n            created.\n        skip_upload (Optional[bool]): Skip upload to server. Default: False.\n    \"\"\"\n\n    # create resolved venv based on distributed venv with Desktop + activated\n    # addons\n    tmpdir = tempfile.mkdtemp(prefix=\"ayon_dep-package\")\n    print(\"&gt;&gt;&gt; Creating processing directory {} for {}\".format(\n        tmpdir, bundle_name))\n\n    try:\n        if con is None:\n            con = ayon_api.get_server_api_connection()\n        return _create_package(\n            bundle_name, con, skip_upload, tmpdir, output_dir\n        )\n\n    finally:\n        print(\"&gt;&gt;&gt; Cleaning up processing directory {}\".format(tmpdir))\n        failed_paths = _remove_tmpdir(tmpdir)\n        if failed_paths:\n            print(\"Failed to cleanup tempdir: {}\".format(tmpdir))\n            print(\"\\n\".join(sorted(failed_paths)))\n</code></pre>"},{"location":"autoapi/dependencies/__main__.html","title":"__main__","text":""},{"location":"autoapi/dependencies/__main__.html#dependencies.__main__--dependencies","title":"dependencies","text":"<p>Usage:</p> <pre><code>dependencies [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"autoapi/dependencies/__main__.html#dependencies.__main__--create","title":"create","text":"<p>Create dependency package for release bundle</p> <p>Usage:</p> <pre><code>dependencies create [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -b, --bundle-name TEXT  Bundle name for which dep package is created\n                          [required]\n  --output-dir TEXT       Directory where created package can be saved\n  --skip-upload           Skip upload of created package to AYON server\n  --server TEXT           AYON server url\n  --api-key TEXT          Api key\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"autoapi/dependencies/__main__.html#dependencies.__main__--list-bundles","title":"list-bundles","text":"<p>List available bundles on AYON server</p> <p>Usage:</p> <pre><code>dependencies list-bundles [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --server TEXT   AYON server url\n  --api-key TEXT  Api key\n  --help          Show this message and exit.\n</code></pre>"},{"location":"autoapi/dependencies/_runtime_deps.html","title":"_runtime_deps","text":"<p>Get runtime python modules from build using this script.</p> <p>Execute this script using venv python executable to get runtime python modules. The script is using 'pkg_resources' to get runtime modules and their versions. Output is stored to a json file that must be provided by last argument.</p>"},{"location":"autoapi/dependencies/cli.html","title":"cli","text":""},{"location":"autoapi/dependencies/core.html","title":"core","text":""},{"location":"autoapi/dependencies/core.html#dependencies.core.calculate_hash","title":"<code>calculate_hash(filepath)</code>","text":"<p>Calculate sha256 hash of file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to a file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>File sha256 hashs.</p> Source code in <code>dependencies/core.py</code> <pre><code>def calculate_hash(filepath):\n    \"\"\"Calculate sha256 hash of file.\n\n    Args:\n        filepath (str): Path to a file.\n\n    Returns:\n        str: File sha256 hashs.\n    \"\"\"\n\n    checksum = hashlib.sha256()\n    with open(filepath, \"rb\") as f:\n        for chunk in iter(lambda: f.read(8192), b\"\"):\n            checksum.update(chunk)\n    return checksum.hexdigest()\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.create_package","title":"<code>create_package(bundle_name, con=None, output_dir=None, skip_upload=False)</code>","text":"<p>Pulls all active addons info from server and create dependency package.</p> <ol> <li>Takes base (installer) pyproject.toml, and adds tomls from addons     pyproject.toml (if available).</li> <li>Builds new venv with dependencies only for addons (dependencies already     present in build are filtered out).</li> <li>Uploads zipped venv to server and set it to bundle.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>Name of bundle for which is package created.</p> required <code>con</code> <code>Optional[ServerAPI]</code> <p>Prepared server API object.</p> <code>None</code> <code>output_dir</code> <code>Optional[str]</code> <p>Path to directory where package will be created.</p> <code>None</code> <code>skip_upload</code> <code>Optional[bool]</code> <p>Skip upload to server. Default: False.</p> <code>False</code> Source code in <code>dependencies/core.py</code> <pre><code>def create_package(bundle_name, con=None, output_dir=None, skip_upload=False):\n    \"\"\"Pulls all active addons info from server and create dependency package.\n\n    1. Takes base (installer) pyproject.toml, and adds tomls from addons\n        pyproject.toml (if available).\n    2. Builds new venv with dependencies only for addons (dependencies already\n        present in build are filtered out).\n    3. Uploads zipped venv to server and set it to bundle.\n\n    Args:\n        bundle_name (str): Name of bundle for which is package created.\n        con (Optional[ayon_api.ServerAPI]): Prepared server API object.\n        output_dir (Optional[str]): Path to directory where package will be\n            created.\n        skip_upload (Optional[bool]): Skip upload to server. Default: False.\n    \"\"\"\n\n    # create resolved venv based on distributed venv with Desktop + activated\n    # addons\n    tmpdir = tempfile.mkdtemp(prefix=\"ayon_dep-package\")\n    print(\"&gt;&gt;&gt; Creating processing directory {} for {}\".format(\n        tmpdir, bundle_name))\n\n    try:\n        if con is None:\n            con = ayon_api.get_server_api_connection()\n        return _create_package(\n            bundle_name, con, skip_upload, tmpdir, output_dir\n        )\n\n    finally:\n        print(\"&gt;&gt;&gt; Cleaning up processing directory {}\".format(tmpdir))\n        failed_paths = _remove_tmpdir(tmpdir)\n        if failed_paths:\n            print(\"Failed to cleanup tempdir: {}\".format(tmpdir))\n            print(\"\\n\".join(sorted(failed_paths)))\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_all_addon_tomls","title":"<code>get_all_addon_tomls(con)</code>","text":"<p>Provides list of dict containing addon tomls.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>dict[str, dict[str, Any]]: All addon toml files.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_all_addon_tomls(con: ayon_api.ServerAPI) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Provides list of dict containing addon tomls.\n\n    Returns:\n        dict[str, dict[str, Any]]: All addon toml files.\n    \"\"\"\n\n    tomls = {}\n    response = con.get_addons_info(details=True)\n    for addon_dict in response[\"addons\"]:\n        addon_name = addon_dict[\"name\"]\n        addon_versions = addon_dict[\"versions\"]\n\n        for version_name, addon_version_dict in addon_versions.items():\n            client_pyproject = addon_version_dict.get(\"clientPyproject\")\n            if not client_pyproject:\n                continue\n            full_name = f\"{addon_name}_{version_name}\"\n            tomls[full_name] = client_pyproject\n\n    return tomls\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_applicable_package","title":"<code>get_applicable_package(con, new_toml)</code>","text":"<p>Compares existing dependency packages to find matching.</p> <p>One dep package could contain same versions of python dependencies for different versions of addons (eg. no change in dependency, but change in functionality)</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>ServerApi</code> <p>Connection to AYON server.</p> required <code>new_toml</code> <code>dict[str, Any]</code> <p>Data of regular pyproject.toml file.</p> required <p>Returns:</p> Type Description <code>Union[Dict[str, Any], None]</code> <p>Union[dict[str, Any], None]: Data of matching package.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_applicable_package(\n    con: ayon_api.ServerAPI, new_toml: Dict[str, Any]\n) -&gt; Union[Dict[str, Any], None]:\n    \"\"\"Compares existing dependency packages to find matching.\n\n    One dep package could contain same versions of python dependencies for\n    different versions of addons (eg. no change in dependency, but change in\n    functionality)\n\n    Args:\n        con (ayon_api.ServerApi): Connection to AYON server.\n        new_toml (dict[str, Any]): Data of regular pyproject.toml file.\n\n    Returns:\n        Union[dict[str, Any], None]: Data of matching package.\n    \"\"\"\n\n    toml_python_packages = dict(\n        sorted(new_toml[\"tool\"][\"poetry\"][\"dependencies\"].items())\n    )\n    for package in con.get_dependency_packages()[\"packages\"]:\n        package_python_packages = dict(sorted(\n            package[\"pythonModules\"].items())\n        )\n        if toml_python_packages == package_python_packages:\n            return package\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_bundle_addons_tomls","title":"<code>get_bundle_addons_tomls(con, bundle)</code>","text":"<p>Query addons for <code>bundle</code> to get their python dependencies.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>dict[str, dict[str, Any]]: {'core_1.0.0': {...toml content...}}</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_bundle_addons_tomls(\n    con: ayon_api.ServerAPI, bundle: Bundle\n) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Query addons for `bundle` to get their python dependencies.\n\n    Returns:\n        dict[str, dict[str, Any]]: {'core_1.0.0': {...toml content...}}\n    \"\"\"\n\n    bundle_addons = {\n        f\"{key}_{value}\"\n        for key, value in bundle.addons.items()\n        if value is not None\n    }\n    print(\"Getting dependencies for addons:\")\n    for addon in bundle_addons:\n        print(f\"  - {addon}\")\n    addon_tomls = get_all_addon_tomls(con)\n\n    return {\n        addon_full_name: toml\n        for addon_full_name, toml in addon_tomls.items()\n        if addon_full_name in bundle_addons\n    }\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_bundles","title":"<code>get_bundles(con)</code>","text":"<p>Provides dictionary with available bundles</p> <p>Returns:</p> Type Description <code>Dict[str, Bundle]</code> <p>(dict) of (Bundle) {\"BUNDLE_NAME\": Bundle}</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_bundles(con: ayon_api.ServerAPI) -&gt; Dict[str, Bundle]:\n    \"\"\"Provides dictionary with available bundles\n\n    Returns:\n        (dict) of (Bundle) {\"BUNDLE_NAME\": Bundle}\n    \"\"\"\n    bundles_by_name = {}\n    for bundle_dict in con.get_bundles()[\"bundles\"]:\n        try:\n            bundle = Bundle(\n                name=bundle_dict[\"name\"],\n                installer_version=bundle_dict[\"installerVersion\"],\n                addons=bundle_dict[\"addons\"],\n                dependency_packages=bundle_dict[\"dependencyPackages\"],\n            )\n        except KeyError:\n            print(f\"Wrong bundle definition for {bundle_dict['name']}\")\n            continue\n        bundles_by_name[bundle.name] = bundle\n    return bundles_by_name\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_full_toml","title":"<code>get_full_toml(base_toml_data, addon_tomls, platform_name)</code>","text":"<p>Loops through list of local addon folder paths to create full .toml</p> <p>Full toml is used to calculate set of python dependencies for all enabled addons.</p> <p>Parameters:</p> Name Type Description Default <code>base_toml_data</code> <code>dict[str, Any]</code> <p>Content of pyproject.toml from ayon-launcher installer.</p> required <code>addon_tomls</code> <code>dict[str, Any]</code> <p>Content of addon pyproject.toml</p> required <code>platform_name</code> <code>str</code> <p>Platform name.</p> required <p>Returns:</p> Type Description <p>(dict) updated base .toml</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_full_toml(base_toml_data, addon_tomls, platform_name):\n    \"\"\"Loops through list of local addon folder paths to create full .toml\n\n    Full toml is used to calculate set of python dependencies for all enabled\n    addons.\n\n    Args:\n        base_toml_data (dict[str, Any]): Content of pyproject.toml from\n            ayon-launcher installer.\n        addon_tomls (dict[str, Any]): Content of addon pyproject.toml\n        platform_name (str): Platform name.\n\n    Returns:\n        (dict) updated base .toml\n    \"\"\"\n\n    # Fix git sources of installer dependencies\n    main_dependencies = base_toml_data[\"tool\"][\"poetry\"][\"dependencies\"]\n    modified_dependencies = {}\n    for key, value in main_dependencies.items():\n        if not isinstance(value, str):\n            continue\n\n        if not is_url(value) and not value.startswith(\"git+http\"):\n            continue\n\n        new_value = None\n        link = Link(value)\n        # TODO handler other version-less contraints\n        if link.scheme.startswith(\"git+\"):\n            url = ParsedUrl.parse(link.url)\n            new_value = {\"git\": url.url}\n            if url.rev:\n                new_value[\"rev\"] = url.rev\n\n        elif link.scheme == \"git\":\n            new_value = {\n                \"git\": link.url_without_fragment\n            }\n\n        modified_dependencies[key] = new_value\n    main_dependencies.update(modified_dependencies)\n    for addon_name, addon_toml_data in tuple(addon_tomls.items()):\n        if isinstance(addon_toml_data, str):\n            addon_tomls[addon_name] = toml.loads(addon_toml_data)\n\n    # Merge addon dependencies\n    for addon_name, addon_toml_data in addon_tomls.items():\n        print(f\"Merging in {addon_name} dependencies\")\n\n        base_toml_data = merge_tomls_dependencies(\n            base_toml_data, addon_toml_data, addon_name\n        )\n\n    for addon_name, addon_toml_data in addon_tomls.items():\n        print(f\"Merging in {addon_name} runtime dependencies\")\n\n        base_toml_data = merge_tomls_runtime(\n            base_toml_data, addon_toml_data, addon_name, platform_name\n        )\n\n    # Convert all 'ConstraintClassesHint' to 'str'\n    main_dependencies = base_toml_data[\"tool\"][\"poetry\"][\"dependencies\"]\n    modified_dependencies = {}\n    for key, value in main_dependencies.items():\n        if not isinstance(value, (str, dict)):\n            modified_dependencies[key] = str(value)\n    main_dependencies.update(modified_dependencies)\n\n    print(\"Collected dependencies:\")\n    for key, value in sorted(main_dependencies.items()):\n        print(f\"  - {key} ({value})\")\n\n    return base_toml_data\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_installer_toml","title":"<code>get_installer_toml(installer)</code>","text":"<p>Returns dict with format matching of .toml file for <code>installer_name</code>.</p> <p>Queries info from server for <code>bundle_name</code> and its <code>installer_name</code>, transforms its list of python dependencies into dictionary matching format of <code>.toml</code></p> Example output <p>{\"tool\": {\"poetry\": {\"dependencies\": {\"somepymodule\": \"1.0.0\"...}}}}</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>dict[str, Any]: Installer toml content.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_installer_toml(installer: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Returns dict with format matching of .toml file for `installer_name`.\n\n    Queries info from server for `bundle_name` and its `installer_name`,\n    transforms its list of python dependencies into dictionary matching format\n    of `.toml`\n\n    Example output:\n        {\"tool\": {\"poetry\": {\"dependencies\": {\"somepymodule\": \"1.0.0\"...}}}}\n\n    Args:\n        installer (dict[str, Any])\n\n    Returns:\n        dict[str, Any]: Installer toml content.\n    \"\"\"\n\n    python_modules = copy.deepcopy(installer[\"pythonModules\"])\n    python_modules[\"python\"] = installer[\"pythonVersion\"]\n    return {\n        \"tool\": {\n            \"poetry\": {\n                # Create copy to avoid modifying original data\n                \"dependencies\": python_modules,\n\n                # These data have no effect, but are required by poetry\n                \"name\": \"AYONDepPackage\",\n                \"version\": \"1.0.0\",\n                \"description\": \"Dependency package for AYON\",\n                \"authors\": [\"Ynput s.r.o. &lt;info@openpype.io&gt;\"],\n                \"license\": \"MIT License\",\n            }\n        },\n        \"ayon\": {\n            \"runtimeDependencies\": copy.deepcopy(\n                installer[\"runtimePythonModules\"]\n            )\n        }\n    }\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_poetry_install_script","title":"<code>get_poetry_install_script()</code>","text":"<p>Get Poetry install script path.</p> <p>Script is cached in downloads folder. If script is not cached ye, it     will be downloaded.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to poetry install script.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_poetry_install_script() -&gt; str:\n    \"\"\"Get Poetry install script path.\n\n    Script is cached in downloads folder. If script is not cached ye, it\n        will be downloaded.\n\n    Returns:\n        str: Path to poetry install script.\n    \"\"\"\n\n    downloads_dir = os.path.join(PACKAGE_ROOT, \"downloads\")\n    if not os.path.exists(downloads_dir):\n        os.makedirs(downloads_dir)\n    poetry_script_path = os.path.join(\n        downloads_dir, f\"poetry-install-script.py\")\n    if os.path.exists(poetry_script_path):\n        return poetry_script_path\n    response = requests.get(\"https://install.python-poetry.org\")\n    with open(poetry_script_path, \"wb\") as stream:\n        stream.write(response.content)\n    return poetry_script_path\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_pyenv_arguments","title":"<code>get_pyenv_arguments(output_root, python_version)</code>","text":"<p>Use pyenv to install python version and use for venv creation.</p> <p>Usage of pyenv is ideal as it allows to properly install runtime     dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>output_root</code> <code>str</code> <p>Path to processing root.</p> required <code>python_version</code> <code>str</code> <p>Python version to install.</p> required <p>Returns:</p> Type Description <code>Union[List[str], None]</code> <p>Union[list[str], None]: List of arguments for subprocess or None.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_pyenv_arguments(\n    output_root: str, python_version: str\n) -&gt; Union[List[str], None]:\n    \"\"\"Use pyenv to install python version and use for venv creation.\n\n    Usage of pyenv is ideal as it allows to properly install runtime\n        dependencies.\n\n    Args:\n        output_root (str): Path to processing root.\n        python_version (str): Python version to install.\n\n    Returns:\n        Union[list[str], None]: List of arguments for subprocess or None.\n    \"\"\"\n\n    pyenv_path = shutil.which(\"pyenv\")\n    if not pyenv_path:\n        return\n    print(f\"Installing Python {python_version} with pyenv\")\n    install_args = [pyenv_path, \"install\", python_version, \"--skip-existing\"]\n    if platform.system().lower() == \"windows\":\n        install_args.append(\"--quiet\")\n    result = subprocess.run(install_args)\n    if result.returncode != 0:\n        raise RuntimeError(f\"Failed to install python {python_version}\")\n    subprocess.run(\n        [pyenv_path, \"local\", python_version],\n        cwd=output_root\n    )\n    output = subprocess.check_output(\n        [pyenv_path, \"which\", \"python\"],\n        cwd=output_root\n    )\n    python_path = output.decode().strip()\n    return [python_path]\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_python_arguments","title":"<code>get_python_arguments(output_root, python_version)</code>","text":"<p>Get arguments to run python.</p> <p>By default, is trying to use 'pyenv' to install python version and use     it for venv creation. If 'pyenv' is not available, it will use     system python.</p> <p>Parameters:</p> Name Type Description Default <code>output_root</code> <code>str</code> <p>Path to processing root.</p> required <code>python_version</code> <code>str</code> <p>Python version to install.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: List of arguments for subprocess.</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_python_arguments(output_root: str, python_version: str) -&gt; List[str]:\n    \"\"\"Get arguments to run python.\n\n    By default, is trying to use 'pyenv' to install python version and use\n        it for venv creation. If 'pyenv' is not available, it will use\n        system python.\n\n    Args:\n        output_root (str): Path to processing root.\n        python_version (str): Python version to install.\n\n    Returns:\n        list[str]: List of arguments for subprocess.\n    \"\"\"\n\n    args = get_pyenv_arguments(output_root, python_version)\n    if args is not None:\n        return args\n    print(\n        \"Failed to use pyenv. Using system python, this may cause that\"\n        \" package will be incompatible package with installer.\"\n    )\n    python_path = shutil.which(\"python3\")\n    if not python_path:\n        python_path = shutil.which(\"python\")\n    return [python_path]\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.get_python_modules","title":"<code>get_python_modules(venv_path)</code>","text":"<p>Uses pip freeze to get installed libraries from <code>venv_path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>venv_path</code> <code>str</code> <p>absolute path to created dependency package already with removed libraries from installer package</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>dict[str, str] {'acre': '1.0.0',...}</p> Source code in <code>dependencies/core.py</code> <pre><code>def get_python_modules(venv_path: str) -&gt; Dict[str, str]:\n    \"\"\"Uses pip freeze to get installed libraries from `venv_path`.\n\n    Args:\n        venv_path (str): absolute path to created dependency package already\n            with removed libraries from installer package\n\n    Returns:\n        dict[str, str] {'acre': '1.0.0',...}\n    \"\"\"\n\n    pip_executable: str = get_venv_executable(venv_path, \"pip\")\n\n    process: subprocess.Popen = subprocess.Popen(\n        [pip_executable, \"freeze\", venv_path, \"--no-color\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    _stdout, _stderr = process.communicate()\n    if process.returncode != 0:\n        raise RuntimeError(f\"Failed to freeze pip packages.\")\n\n    packages = {}\n    for line in _stdout.decode(\"utf-8\").split(\"\\n\"):\n        line = line.strip()\n        if not line:\n            continue\n\n        match = re.match(r\"^(.+?)(?:==|&gt;=|&lt;=|~=|!=|@)(.+)$\", line)\n        if match:\n            package_name, package_version = match.groups()\n            packages[package_name.rstrip()] = package_version.lstrip()\n        else:\n            packages[line] = None\n\n    print(\"Installed python modules:\")\n    for package in sorted(packages):\n        print(f\"  - {package}\")\n\n    return packages\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.is_file_deletable","title":"<code>is_file_deletable(filepath)</code>","text":"<p>Can be file deleted.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to a file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>File can be removed.</p> Source code in <code>dependencies/core.py</code> <pre><code>def is_file_deletable(filepath):\n    \"\"\"Can be file deleted.\n\n    Args:\n        filepath (str): Path to a file.\n\n    Returns:\n        bool: File can be removed.\n    \"\"\"\n\n    file_dirname = os.path.dirname(filepath)\n    if os.access(file_dirname, os.W_OK | os.X_OK):\n        try:\n            with open(filepath, \"w\"):\n                pass\n            return True\n        except OSError:\n            pass\n\n    return False\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.is_valid_toml","title":"<code>is_valid_toml(toml)</code>","text":"<p>Validates that 'toml' contains all required fields.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all required keys present</p> Source code in <code>dependencies/core.py</code> <pre><code>def is_valid_toml(toml: Dict[str, Any]) -&gt; bool:\n    \"\"\"Validates that 'toml' contains all required fields.\n\n    Args:\n        toml (dict[str, Any])\n\n    Returns:\n        True if all required keys present\n\n    Raises:\n        KeyError\n    \"\"\"\n\n    required_fields = [\"tool.poetry\"]\n    for field in required_fields:\n        fields = field.split(\".\")\n        value = toml\n        while fields:\n            key = fields.pop(0)\n            value = value.get(key)\n\n            if not value:\n                raise KeyError(f\"Toml content must contain {field}\")\n\n    return True\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.lock_to_toml_data","title":"<code>lock_to_toml_data(lock_path)</code>","text":"<p>Create toml file with explicit version from lock file.</p> <p>Should be used to compare addon venv with client venv and purge existing libraries.</p> <p>Parameters:</p> Name Type Description Default <code>lock_path</code> <code>str</code> <p>path to base lock file (from build)</p> required <p>Returns:     (dict): dictionary representation of toml data with explicit library         versions Raises:     (FileNotFound)</p> Source code in <code>dependencies/core.py</code> <pre><code>def lock_to_toml_data(lock_path):\n    \"\"\"Create toml file with explicit version from lock file.\n\n    Should be used to compare addon venv with client venv and purge existing\n    libraries.\n\n    Args:\n        lock_path (str): path to base lock file (from build)\n    Returns:\n        (dict): dictionary representation of toml data with explicit library\n            versions\n    Raises:\n        (FileNotFound)\n    \"\"\"\n\n    if not os.path.exists(lock_path):\n        raise ValueError(\n            f\"{lock_path} doesn't exist. Provide path to real toml.\"\n        )\n\n    with open(lock_path) as fp:\n        parsed = toml.load(fp)\n\n    dependencies = {\n        package_info[\"name\"]: package_info[\"version\"]\n        for package_info in parsed[\"package\"]\n    }\n\n    return {\"tool\": {\"poetry\": {\"dependencies\": dependencies}}}\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.merge_tomls_dependencies","title":"<code>merge_tomls_dependencies(main_toml, addon_toml, addon_name)</code>","text":"<p>Add dependencies from 'addon_toml' to 'main_toml'.</p> <p>Looks for mininimal compatible version from both tomls.</p> Handles sections <ul> <li>[\"tool\"][\"poetry\"][\"dependencies\"]</li> <li>[\"ayon\"][\"runtimeDependencies\"]</li> </ul> <p>Returns:</p> Type Description <code>dict</code> <p>updated 'main_toml' with additional/updated dependencies</p> Source code in <code>dependencies/core.py</code> <pre><code>def merge_tomls_dependencies(\n    main_toml: Dict[str, Dict[str, Any]],\n    addon_toml: Dict[str, Dict[str, Any]],\n    addon_name: str,\n) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Add dependencies from 'addon_toml' to 'main_toml'.\n\n    Looks for mininimal compatible version from both tomls.\n\n    Handles sections:\n        - [\"tool\"][\"poetry\"][\"dependencies\"]\n        - [\"ayon\"][\"runtimeDependencies\"]\n\n    Returns:\n        (dict): updated 'main_toml' with additional/updated dependencies\n\n    Raises:\n        ValueError if any tuple of main and addon dependency cannot be resolved\n    \"\"\"\n\n    main_dependencies = (\n        main_toml[\"tool\"][\"poetry\"].setdefault(\"dependencies\", {})\n    )\n    addon_dependencies = (\n        addon_toml\n        .get(\"tool\", {})\n        .get(\"poetry\", {})\n        .get(\"dependencies\")\n    ) or {}\n\n    for dependency, dep_version in addon_dependencies.items():\n        main_version = main_dependencies.get(dependency)\n        resolved_vers = _get_correct_version(main_version, dep_version)\n        if not main_version:\n            main_version = \"N/A\"\n\n        if (\n            isinstance(resolved_vers, ConstraintClasses)\n            and resolved_vers.is_empty()\n        ):\n            raise ValueError(\n                f\"Version {dep_version} cannot be resolved against\"\n                f\" {main_version} for {dependency} in {addon_name}\"\n            )\n\n        main_dependencies[dependency] = resolved_vers\n\n    return main_toml\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.merge_tomls_runtime","title":"<code>merge_tomls_runtime(main_toml, addon_toml, addon_name, platform_name)</code>","text":"<p>Add dependencies from 'addon_toml' to 'main_toml'.</p> <p>Looks for mininimal compatible version from both tomls.</p> Handles sections <ul> <li>[\"tool\"][\"poetry\"][\"dependencies\"]</li> <li>[\"ayon\"][\"runtimeDependencies\"]</li> </ul> <p>Returns:</p> Type Description <code>dict</code> <p>updated 'main_toml' with additional/updated dependencies</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any tuple of main and addon dependency cannot be resolved.</p> Source code in <code>dependencies/core.py</code> <pre><code>def merge_tomls_runtime(\n    main_toml: Dict[str, Dict[str, Any]],\n    addon_toml: Dict[str, Dict[str, Any]],\n    addon_name: str,\n    platform_name: str,\n) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Add dependencies from 'addon_toml' to 'main_toml'.\n\n    Looks for mininimal compatible version from both tomls.\n\n    Handles sections:\n        - [\"tool\"][\"poetry\"][\"dependencies\"]\n        - [\"ayon\"][\"runtimeDependencies\"]\n\n    Returns:\n        (dict): updated 'main_toml' with additional/updated dependencies\n\n    Raises:\n        ValueError: If any tuple of main and addon dependency\n            cannot be resolved.\n    \"\"\"\n\n    # handle runtime dependencies\n    addon_poetry = addon_toml.get(\"ayon\", {}).get(\"runtimeDependencies\")\n    if not addon_poetry:\n        return main_toml\n\n    main_dependencies = (\n        main_toml[\"tool\"][\"poetry\"].setdefault(\"dependencies\", {})\n    )\n    main_runtime = main_toml[\"ayon\"][\"runtimeDependencies\"]\n    for dependency, dep_info in addon_poetry.items():\n        if isinstance(dep_info, dict):\n            if platform_name in dep_info:\n                dep_info = dep_info[platform_name]\n\n            if \"version\" in dep_info:\n                dep_info = dep_info[\"version\"]\n\n        if dependency in main_dependencies:\n            main_dependencies[dependency] = _merge_dependency(\n                main_dependencies[dependency],\n                dep_info,\n                platform_name,\n                dependency,\n                addon_name\n            )\n            continue\n\n        main_runtime[dependency] = _merge_dependency(\n            main_runtime.get(dependency),\n            dep_info,\n            platform_name,\n            dependency,\n            addon_name\n        )\n\n    return main_toml\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.prepare_new_venv","title":"<code>prepare_new_venv(output_root, installer)</code>","text":"<p>Let Poetry create new venv in 'venv_folder' from 'full_toml_data'.</p> <p>Parameters:</p> Name Type Description Default <code>output_root</code> <code>str</code> <p>Path where venv should be created.</p> required <code>installer</code> <code>dict[str, Any]</code> <p>Installer metadata.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Exception is raised if process finished with nonzero return code.</p> Source code in <code>dependencies/core.py</code> <pre><code>def prepare_new_venv(output_root, installer):\n    \"\"\"Let Poetry create new venv in 'venv_folder' from 'full_toml_data'.\n\n    Args:\n        output_root (str): Path where venv should be created.\n        installer (dict[str, Any]): Installer metadata.\n\n    Raises:\n        RuntimeError: Exception is raised if process finished with nonzero\n            return code.\n    \"\"\"\n\n    print(f\"Preparing new venv in {output_root}\")\n\n    python_version = installer[\"pythonVersion\"]\n\n    python_args = get_python_arguments(output_root, python_version)\n\n    poetry_script = get_poetry_install_script()\n    poetry_home = os.path.join(output_root, \".poetry\")\n    poetry_bin = os.path.join(poetry_home, \"bin\", \"poetry\")\n    venv_path = os.path.join(output_root, \".venv\")\n\n    env = dict(os.environ.items())\n    env[\"POETRY_VERSION\"] = POETRY_VERSION\n    env[\"POETRY_HOME\"] = poetry_home\n    # Create poetry in output root\n    subprocess.call(python_args + [poetry_script], env=env, cwd=output_root)\n\n    # Create venv using poetry\n    run_subprocess(\n        python_args + [\"-m\", \"venv\", venv_path],\n        env=env,\n        cwd=output_root\n    )\n    env[\"VIRTUAL_ENV\"] = venv_path\n    # Change poetry config to ignore venv in poetry\n    for config_key, config_value in (\n        (\"virtualenvs.create\", \"false\"),\n        (\"virtualenvs.in-project\", \"false\"),\n    ):\n        run_subprocess(\n            [poetry_bin, \"config\", config_key, config_value, \"--local\"],\n            env=env,\n            cwd=output_root\n        )\n\n    return VenvInfo(\n        output_root,\n        poetry_bin,\n        env,\n        venv_path,\n        python_version\n    )\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.prepare_package_data","title":"<code>prepare_package_data(venv_zip_path, bundle, platform_name, runtime_dependencies)</code>","text":"<p>Creates package data for server.</p> <p>All data in output are used to call 'create_dependency_package'.</p> <p>Parameters:</p> Name Type Description Default <code>venv_zip_path</code> <code>str</code> <p>Local path to zipped venv.</p> required <code>bundle</code> <code>Bundle</code> <p>Bundle object with all data.</p> required <code>platform_name</code> <code>str</code> <p>Platform name.</p> required <code>runtime_dependencies</code> <code>dict[str, str]</code> <p>Runtime dependencies with requested versions.</p> required <p>Returns:</p> Type Description <p>dict[str, Any]: Dependency package information.</p> Source code in <code>dependencies/core.py</code> <pre><code>def prepare_package_data(\n    venv_zip_path: str,\n    bundle: Bundle,\n    platform_name: str,\n    runtime_dependencies: Dict[str, str],\n):\n    \"\"\"Creates package data for server.\n\n    All data in output are used to call 'create_dependency_package'.\n\n    Args:\n        venv_zip_path (str): Local path to zipped venv.\n        bundle (Bundle): Bundle object with all data.\n        platform_name (str): Platform name.\n        runtime_dependencies (dict[str, str]): Runtime dependencies with\n            requested versions.\n\n    Returns:\n        dict[str, Any]: Dependency package information.\n    \"\"\"\n\n    venv_path = os.path.join(os.path.dirname(venv_zip_path), \".venv\")\n    python_modules = get_python_modules(venv_path)\n    # Runtime dependencies do not have special key\n    python_modules.update(runtime_dependencies)\n\n    package_name = os.path.basename(venv_zip_path)\n    checksum = calculate_hash(venv_zip_path)\n\n    return {\n        \"filename\": package_name,\n        \"python_modules\": python_modules,\n        \"source_addons\": bundle.addons,\n        \"installer_version\": bundle.installer_version,\n        \"checksum\": checksum,\n        \"checksum_algorithm\": \"sha256\",\n        \"file_size\": os.stat(venv_zip_path).st_size,\n        \"platform_name\": platform_name,\n    }\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.prepare_zip_venv","title":"<code>prepare_zip_venv(venv_path, runtime_site_packages, output_root)</code>","text":"<p>Handles creation of zipped venv.</p> <p>Parameters:</p> Name Type Description Default <code>venv_path</code> <code>str</code> <p>Path to created venv.</p> required <code>runtime_site_packages</code> <code>str</code> <p>Path to runtime dependencies.</p> required <code>output_root</code> <code>str</code> <p>Temp folder path.</p> required <p>Returns:</p> Type Description <p>(str) path to zipped venv</p> Source code in <code>dependencies/core.py</code> <pre><code>def prepare_zip_venv(venv_path, runtime_site_packages, output_root):\n    \"\"\"Handles creation of zipped venv.\n\n    Args:\n        venv_path (str): Path to created venv.\n        runtime_site_packages (str): Path to runtime dependencies.\n        output_root (str): Temp folder path.\n\n    Returns:\n        (str) path to zipped venv\n    \"\"\"\n    basename = create_dependency_package_basename()\n    if platform.system().lower() == \"linux\":\n        basename += f\"-{distro.id()}{distro.major_version()}\"\n    zip_file_name = f\"{basename}.zip\"\n    venv_zip_path = os.path.join(output_root, zip_file_name)\n    print(f\"Zipping new venv to {venv_zip_path}\")\n    zip_venv(venv_path, runtime_site_packages, venv_zip_path)\n\n    return venv_zip_path\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.remove_existing_from_venv","title":"<code>remove_existing_from_venv(addons_venv_path, installer, installed_installer_runtime_deps)</code>","text":"<p>Loop through calculated addon venv and remove already installed libs.</p> <p>Parameters:</p> Name Type Description Default <code>addons_venv_path</code> <code>str</code> <p>Path to newly created merged venv for active addons.</p> required <code>installer</code> <code>dict[str, Any]</code> <p>installer data from server.</p> required <code>installed_installer_runtime_deps</code> <code>set[str]</code> <p>Installed runtime dependencies.</p> required <p>Returns:</p> Type Description <p>(set) of folder/file paths that were removed from addon venv, used only for testing</p> Source code in <code>dependencies/core.py</code> <pre><code>def remove_existing_from_venv(\n    addons_venv_path,\n    installer,\n    installed_installer_runtime_deps\n):\n    \"\"\"Loop through calculated addon venv and remove already installed libs.\n\n    Args:\n        addons_venv_path (str): Path to newly created merged venv for active\n            addons.\n        installer (dict[str, Any]): installer data from server.\n        installed_installer_runtime_deps (set[str]): Installed runtime\n            dependencies.\n\n    Returns:\n        (set) of folder/file paths that were removed from addon venv, used only\n            for testing\n    \"\"\"\n\n    pip_executable = get_venv_executable(addons_venv_path, \"pip\")\n    print(\"Removing packages from venv\")\n    for package_name in sorted(\n        set(installer[\"pythonModules\"])\n        | set(installed_installer_runtime_deps)\n    ):\n        # Fix 'Babel'\n        # TODO fix in ayon-launcher\n        if package_name == \"Babel\":\n            package_name = \"babel\"\n        print(f\"- {package_name}\")\n        run_subprocess(\n            [pip_executable, \"uninstall\", package_name, \"--yes\"],\n            bound_output=False\n        )\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.stored_package_to_dir","title":"<code>stored_package_to_dir(output_dir, venv_zip_path, bundle, package_data)</code>","text":"<p>Store dependency package to output directory.</p> <p>A json file with dependency package information is created and stored next to the dependency package file (replaced extension with .json).</p> <p>Bundle name is added to dependency package before saving.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Path where dependency package will be stored.</p> required <code>venv_zip_path</code> <code>str</code> <p>Local path to zipped venv.</p> required <code>bundle</code> <code>Bundle</code> <p>Bundle object with all data.</p> required <code>package_data</code> <code>dict[str, Any]</code> <p>Dependency package information.</p> required Source code in <code>dependencies/core.py</code> <pre><code>def stored_package_to_dir(output_dir, venv_zip_path, bundle, package_data):\n    \"\"\"Store dependency package to output directory.\n\n    A json file with dependency package information is created and stored\n    next to the dependency package file (replaced extension with .json).\n\n    Bundle name is added to dependency package before saving.\n\n    Args:\n        output_dir (str): Path where dependency package will be stored.\n        venv_zip_path (str): Local path to zipped venv.\n        bundle (Bundle): Bundle object with all data.\n        package_data (dict[str, Any]): Dependency package information.\n    \"\"\"\n\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    new_package_data = copy.deepcopy(package_data)\n    # Change data to match server requirements\n    new_package_data[\"platform\"] = new_package_data.pop(\"platform_name\")\n    new_package_data[\"size\"] = new_package_data.pop(\"file_size\")\n    # Add bundle name as information\n    new_package_data[\"bundle_name\"] = bundle.name\n\n    filename = new_package_data[\"filename\"]\n    output_path = os.path.join(output_dir, filename)\n    shutil.copy(venv_zip_path, output_path)\n    metadata_path = output_path + \".json\"\n    with open(metadata_path, \"w\") as stream:\n        json.dump(new_package_data, stream, indent=4)\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.update_bundle_with_package","title":"<code>update_bundle_with_package(con, bundle, package_data)</code>","text":"<p>Assign <code>package_name</code> to <code>bundle</code></p> Source code in <code>dependencies/core.py</code> <pre><code>def update_bundle_with_package(con, bundle, package_data):\n    \"\"\"Assign `package_name` to `bundle`\n\n    Args:\n        con (ayon_api.ServerAPI)\n        bundle (Bundle)\n        package_data (dict[str, Any])\n    \"\"\"\n\n    package_name = package_data[\"filename\"]\n    print(f\"Updating in {bundle.name} with {package_name}\")\n    platform_name = package_data[\"platform_name\"]\n    dependency_packages = copy.deepcopy(bundle.dependency_packages)\n    dependency_packages[platform_name] = package_name\n    con.update_bundle(bundle.name, dependency_packages)\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.upload_to_server","title":"<code>upload_to_server(con, venv_zip_path, package_data)</code>","text":"<p>Creates and uploads package on the server</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>ServerAPI</code> <p>Connection to server.</p> required <code>venv_zip_path</code> <code>str</code> <p>Local path to zipped venv.</p> required <code>package_data</code> <code>dict[str, Any]</code> <p>Package information.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Package name.</p> Source code in <code>dependencies/core.py</code> <pre><code>def upload_to_server(con, venv_zip_path, package_data):\n    \"\"\"Creates and uploads package on the server\n\n    Args:\n        con (ayon_api.ServerAPI): Connection to server.\n        venv_zip_path (str): Local path to zipped venv.\n        package_data (dict[str, Any]): Package information.\n\n    Returns:\n        str: Package name.\n    \"\"\"\n\n    con.create_dependency_package(**package_data)\n    con.upload_dependency_package(\n        venv_zip_path,\n        package_data[\"filename\"]\n    )\n</code></pre>"},{"location":"autoapi/dependencies/core.html#dependencies.core.zip_venv","title":"<code>zip_venv(venv_folder, runtime_site_packages, zip_filepath)</code>","text":"<p>Zips newly created venv to single .zip file.</p> Source code in <code>dependencies/core.py</code> <pre><code>def zip_venv(venv_folder, runtime_site_packages, zip_filepath):\n    \"\"\"Zips newly created venv to single .zip file.\"\"\"\n\n    site_packages_roots = get_venv_site_packages(venv_folder)\n    with ZipFileLongPaths(zip_filepath, \"w\", zipfile.ZIP_DEFLATED) as zipf:\n        for site_packages_root in site_packages_roots:\n            sp_root_len_start = len(site_packages_root) + 1\n            for root, _, filenames in os.walk(site_packages_root):\n                # Care only about files\n                if not filenames:\n                    continue\n\n                # Skip __pycache__ folders\n                root_name = os.path.basename(root)\n                if root_name == \"__pycache__\":\n                    continue\n\n                dst_root = \"dependencies\"\n                if len(root) &gt; sp_root_len_start:\n                    dst_root = os.path.join(dst_root, root[sp_root_len_start:])\n\n                for filename in filenames:\n                    src_path = os.path.join(root, filename)\n                    dst_path = os.path.join(dst_root, filename)\n                    zipf.write(src_path, dst_path)\n\n        zip_runtime_root = \"runtime\"\n        for root, _, filenames in os.walk(runtime_site_packages):\n            # Care only about files\n            if not filenames:\n                continue\n\n            dst_root = zip_runtime_root\n            if root != runtime_site_packages:\n                dst_root = os.path.join(\n                    dst_root, root[len(runtime_site_packages) + 1:]\n                )\n\n            for filename in filenames:\n                src_path = os.path.join(root, filename)\n                dst_path = os.path.join(dst_root, filename)\n                zipf.write(src_path, dst_path)\n</code></pre>"},{"location":"autoapi/dependencies/custom_solver.html","title":"custom_solver","text":""},{"location":"autoapi/dependencies/utils.html","title":"utils","text":""},{"location":"autoapi/dependencies/utils.html#dependencies.utils.ZipFileLongPaths","title":"<code>ZipFileLongPaths</code>","text":"<p>               Bases: <code>ZipFile</code></p> <p>Allows longer paths in zip files.</p> <p>Regular DOS paths are limited to MAX_PATH (260) characters, including the string's terminating NUL character. That limit can be exceeded by using an extended-length path that starts with the '\\?' prefix.</p> Source code in <code>dependencies/utils.py</code> <pre><code>class ZipFileLongPaths(zipfile.ZipFile):\n    \"\"\"Allows longer paths in zip files.\n\n    Regular DOS paths are limited to MAX_PATH (260) characters, including\n    the string's terminating NUL character.\n    That limit can be exceeded by using an extended-length path that\n    starts with the '\\\\?\\' prefix.\n    \"\"\"\n    _is_windows = platform.system().lower() == \"windows\"\n\n    def _extract_member(self, member, tpath, pwd):\n        if self._is_windows:\n            tpath = os.path.abspath(tpath)\n            if tpath.startswith(\"\\\\\\\\\"):\n                tpath = \"\\\\\\\\?\\\\UNC\\\\\" + tpath[2:]\n            else:\n                tpath = \"\\\\\\\\?\\\\\" + tpath\n\n        return super(ZipFileLongPaths, self)._extract_member(\n            member, tpath, pwd\n        )\n</code></pre>"},{"location":"autoapi/dependencies/utils.html#dependencies.utils.get_venv_executable","title":"<code>get_venv_executable(venv_root, executable='python')</code>","text":"<p>Get path to executable in virtual environment.</p> <p>Parameters:</p> Name Type Description Default <code>venv_root</code> <code>str</code> <p>Path to venv root.</p> required <code>executable</code> <code>Optional[str]</code> <p>Name of executable. Defaults to \"python\".</p> <code>'python'</code> Source code in <code>dependencies/utils.py</code> <pre><code>def get_venv_executable(venv_root, executable=\"python\"):\n    \"\"\"Get path to executable in virtual environment.\n\n    Args:\n        venv_root (str): Path to venv root.\n        executable (Optional[str]): Name of executable. Defaults to \"python\".\n    \"\"\"\n\n    if platform.system().lower() == \"windows\":\n        bin_folder = \"Scripts\"\n    else:\n        bin_folder = \"bin\"\n    return os.path.join(venv_root, bin_folder, executable)\n</code></pre>"},{"location":"autoapi/dependencies/utils.html#dependencies.utils.get_venv_site_packages","title":"<code>get_venv_site_packages(venv_root)</code>","text":"<p>Path to site-packages folder in virtual environment.</p> Todos <p>Find more elegant way to get site-packages paths.</p> <p>Parameters:</p> Name Type Description Default <code>venv_root</code> <code>str</code> <p>Path to venv root.</p> required <p>Returns:</p> Type Description <p>list[str]: Normalized paths to site-packages dirs.</p> Source code in <code>dependencies/utils.py</code> <pre><code>def get_venv_site_packages(venv_root):\n    \"\"\"Path to site-packages folder in virtual environment.\n\n    Todos:\n        Find more elegant way to get site-packages paths.\n\n    Args:\n        venv_root (str): Path to venv root.\n\n    Returns:\n        list[str]: Normalized paths to site-packages dirs.\n    \"\"\"\n\n    output = []\n    for root, dirnames, _ in os.walk(venv_root):\n        for dirname in dirnames:\n            if dirname == \"site-packages\":\n                output.append(os.path.join(root, dirname))\n    return output\n</code></pre>"},{"location":"autoapi/dependencies/utils.html#dependencies.utils.run_subprocess","title":"<code>run_subprocess(cmd_args, *args, bound_output=True, **kwargs)</code>","text":"<p>Convenience method for getting output errors for subprocess.</p> <p>Output logged when process finish.</p> <p>Entered arguments and keyword arguments are passed to subprocess Popen.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_args</code> <code>Union[Iterable[str], str]</code> <p>Command or list of arguments passed to Popen.</p> required <code>*args</code> <p>Variable length arument list passed to Popen.</p> <code>()</code> <code>bound_output</code> <code>bool</code> <p>Output will be printed with bounded margins.</p> <code>True</code> <code>**kwargs</code> <p>Arbitrary keyword arguments passed to Popen. Is possible to pass <code>logging.Logger</code> object under \"logger\" if want to use different than lib's logger.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>int</code> <p>Returncode of process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Exception is raised if process finished with nonzero return code.</p> Source code in <code>dependencies/utils.py</code> <pre><code>def run_subprocess(\n    cmd_args, *args, bound_output=True, **kwargs\n):\n    \"\"\"Convenience method for getting output errors for subprocess.\n\n    Output logged when process finish.\n\n    Entered arguments and keyword arguments are passed to subprocess Popen.\n\n    Args:\n        cmd_args (Union[Iterable[str], str]): Command or list of arguments\n            passed to Popen.\n        *args: Variable length arument list passed to Popen.\n        bound_output (bool): Output will be printed with bounded margins.\n        **kwargs : Arbitrary keyword arguments passed to Popen. Is possible to\n            pass `logging.Logger` object under \"logger\" if want to use\n            different than lib's logger.\n\n    Returns:\n        int: Returncode of process.\n\n    Raises:\n        RuntimeError: Exception is raised if process finished with nonzero\n            return code.\n    \"\"\"\n\n    # Get environents from kwarg or use current process environments if were\n    # not passed.\n    env = kwargs.get(\"env\") or os.environ\n    # Make sure environment contains only strings\n    filtered_env = {str(k): str(v) for k, v in env.items()}\n\n    # set overrides\n    kwargs[\"env\"] = filtered_env\n    kwargs[\"stdin\"] = subprocess.PIPE\n    kwargs[\"stdout\"] = sys.stdout\n    kwargs[\"stderr\"] = sys.stderr\n\n    cmd = subprocess.list2cmdline(cmd_args)\n    proc = subprocess.Popen(cmd_args, *args, **kwargs)\n    while proc.poll() is None:\n        time.sleep(0.1)\n\n    if proc.returncode != 0:\n        error_msg = f\"Executing arguments was not successful: {cmd}\"\n        print(error_msg)\n        raise RuntimeError(error_msg)\n    return proc.returncode\n</code></pre>"},{"location":"autoapi/dependencies/tests/index.html","title":"tests","text":""},{"location":"autoapi/dependencies/tests/test_dependencies.html","title":"test_dependencies","text":""},{"location":"autoapi/dependencies/tests/test_dependencies.html#dependencies.tests.test_dependencies.addon_toml_to_compare_data","title":"<code>addon_toml_to_compare_data()</code>","text":"<p>Test file contains dummy data to test version compare</p> Source code in <code>dependencies/tests/test_dependencies.py</code> <pre><code>@pytest.fixture\ndef addon_toml_to_compare_data():\n    \"\"\"Test file contains dummy data to test version compare\"\"\"\n    provider = FileTomlProvider(os.path.join(TEST_RESOURCES_DIR,\n                                             \"pyproject.toml\"))\n    return provider.get_toml()\n</code></pre>"},{"location":"autoapi/dependencies/tests/test_dependencies.html#dependencies.tests.test_dependencies.addon_toml_to_venv_data","title":"<code>addon_toml_to_venv_data()</code>","text":"<p>Test file contains 'close to live' toml for single addon.</p> Source code in <code>dependencies/tests/test_dependencies.py</code> <pre><code>@pytest.fixture\ndef addon_toml_to_venv_data():\n    \"\"\"Test file contains 'close to live' toml for single addon.\"\"\"\n    provider = FileTomlProvider(os.path.join(TEST_RESOURCES_DIR,\n                                             \"pyproject_clean.toml\"))\n    return provider.get_toml()\n</code></pre>"},{"location":"autoapi/dependencies/tests/test_dependencies.html#dependencies.tests.test_dependencies.test_convert_url_constraints_git_dependency","title":"<code>test_convert_url_constraints_git_dependency(full_toml_data)</code>","text":"<p>Tests that the <code>_convert_url_constraints()</code> method correctly converts a Git dependency.</p> Source code in <code>dependencies/tests/test_dependencies.py</code> <pre><code>def test_convert_url_constraints_git_dependency(full_toml_data):\n    \"\"\"Tests that the `_convert_url_constraints()` method correctly converts\n    a Git dependency.\"\"\"\n    full_toml_data[\"tool\"][\"poetry\"][\"dependencies\"] = {\n        \"mypackage\": \"git+https://github.com/myusername/mypackage@v1.2.3\"\n    }\n    _convert_url_constraints(full_toml_data)\n    assert full_toml_data[\"tool\"][\"poetry\"][\"dependencies\"][\"mypackage\"] == {\n        \"git\": \"https://github.com/myusername/mypackage\",\n        \"rev\": \"v1.2.3\"\n    }\n</code></pre>"},{"location":"autoapi/dependencies/tests/test_dependencies.html#dependencies.tests.test_dependencies.test_convert_url_constraints_http_dependency","title":"<code>test_convert_url_constraints_http_dependency(full_toml_data)</code>","text":"<p>Tests that the <code>_convert_url_constraints()</code> method correctly converts an HTTP dependency.</p> Source code in <code>dependencies/tests/test_dependencies.py</code> <pre><code>def test_convert_url_constraints_http_dependency(full_toml_data):\n    \"\"\"Tests that the `_convert_url_constraints()` method correctly converts\n    an HTTP dependency.\"\"\"\n    full_toml_data[\"tool\"][\"poetry\"][\"dependencies\"] = {\n        \"requests\": \"http://github.com/kennethreitz/requests@2.27.1\"\n    }\n    _convert_url_constraints(full_toml_data)\n    assert full_toml_data[\"tool\"][\"poetry\"][\"dependencies\"][\"requests\"] == {\n        \"url\": \"http://github.com/kennethreitz/requests@2.27.1\"\n    }\n</code></pre>"},{"location":"autoapi/dependencies/tests/test_dependencies.html#dependencies.tests.test_dependencies.test_prepare_new_venv","title":"<code>test_prepare_new_venv(addon_toml_to_venv_data, tmpdir)</code>","text":"<p>Creates zip of simple venv from mock addon pyproject data</p> Source code in <code>dependencies/tests/test_dependencies.py</code> <pre><code>def test_prepare_new_venv(addon_toml_to_venv_data, tmpdir):\n    \"\"\"Creates zip of simple venv from mock addon pyproject data\"\"\"\n    print(f\"Creating new venv in {tmpdir}\")\n    return_code = prepare_new_venv(addon_toml_to_venv_data, tmpdir)\n\n    assert return_code != 1, \"Prepare of new venv failed\"\n\n    inst_lib = os.path.join(tmpdir, '.venv', 'Lib', 'site-packages', 'aiohttp')\n    assert os.path.exists(inst_lib), \"aiohttp should be installed\"\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/service/__main__.html","title":"__main__","text":"<p>Launch listener locally for testing purposes.</p> <p>This script will add 'dependencies' to 'sys.path' to be able to launch listener.</p>"},{"location":"autoapi/service/listener.html","title":"listener","text":""},{"location":"autoapi/service/listener.html#service.listener.DependenciesToolListener","title":"<code>DependenciesToolListener</code>","text":"Source code in <code>service/listener.py</code> <pre><code>class DependenciesToolListener:\n    def __init__(self):\n        \"\"\" Listener on \"bundle.updated\" topic.\n\n        This topic should contain events triggered by Server after bundle is\n        created or updated to start full creation of dependency package.\n\n        After consuming event from `\"bundle.updated\"` topic new event is\n        created on \"dependencies.creating_package.{platform_name}\" to follow\n        state of creation job.\n\n        There might be multiple processing workers, each for specific OS. Each\n        is automatically listening on separate topic.\n\n        It is responsibility of server (or addon) to trigger so many events on\n        so many topics as it is required.\n        \"\"\"\n        logging.info(\"Initializing the Dependencies Tool Listener.\")\n\n        self.worker_id = \"my_id\"  # TODO get from Server\n\n        signal.signal(signal.SIGINT, self._signal_teardown_handler)\n        signal.signal(signal.SIGTERM, self._signal_teardown_handler)\n\n    def _signal_teardown_handler(self, signalnum, frame):\n        logging.warning(\"Process stop requested. Terminating process.\")\n        logging.warning(\"Termination finished.\")\n        sys.exit(0)\n\n    def start_listening(self):\n        \"\"\" Main loop querying the AYON event loop\n        \"\"\"\n        logging.info(\"Start listening for Ayon Events...\")\n\n        platform_name = platform.system().lower()\n        target_topic = f\"dependencies.creating_package.{platform_name}\"\n\n        while True:\n            event = ayon_api.enroll_event_job(\n                SOURCE_TOPIC,\n                target_topic,\n                self.worker_id,\n                \"Creating dependency package\",\n                # Creation of dependency packages is not sequential process\n                sequential=False,\n            )\n            if not event:\n                time.sleep(2)\n                continue\n\n            src_job = ayon_api.get_event(event[\"dependsOn\"])\n            bundle_name = src_job[\"summary\"][\"name\"]\n            try:\n                package_name = self.process_create_dependency(bundle_name)\n                description = f\"{package_name} created\"\n                status = \"finished\"\n            except Exception as e:\n                status = \"finished\"\n                description = f\"Creation of package for {bundle_name} failed\\n{str(e)}\"  # noqa\n                log_traceback(e)\n\n            ayon_api.update_event(\n                event[\"id\"],\n                sender=self.worker_id,\n                status=status,\n                description=description,\n            )\n\n    def process_create_dependency(self, bundle_name):\n        \"\"\"Calls full creation dependency package process\n\n        Expects env vars:\n            AYON_SERVER_URL\n            AYON_API_KEY\n\n        Args:\n            bundle_name (str): for which bundle dependency packages should be\n                created\n\n        Returns:\n            (str): created package name\n        \"\"\"\n        return create_package(bundle_name)\n</code></pre>"},{"location":"autoapi/service/listener.html#service.listener.DependenciesToolListener.__init__","title":"<code>__init__()</code>","text":"<p>Listener on \"bundle.updated\" topic.</p> <p>This topic should contain events triggered by Server after bundle is created or updated to start full creation of dependency package.</p> <p>After consuming event from <code>\"bundle.updated\"</code> topic new event is created on \"dependencies.creating_package.{platform_name}\" to follow state of creation job.</p> <p>There might be multiple processing workers, each for specific OS. Each is automatically listening on separate topic.</p> <p>It is responsibility of server (or addon) to trigger so many events on so many topics as it is required.</p> Source code in <code>service/listener.py</code> <pre><code>def __init__(self):\n    \"\"\" Listener on \"bundle.updated\" topic.\n\n    This topic should contain events triggered by Server after bundle is\n    created or updated to start full creation of dependency package.\n\n    After consuming event from `\"bundle.updated\"` topic new event is\n    created on \"dependencies.creating_package.{platform_name}\" to follow\n    state of creation job.\n\n    There might be multiple processing workers, each for specific OS. Each\n    is automatically listening on separate topic.\n\n    It is responsibility of server (or addon) to trigger so many events on\n    so many topics as it is required.\n    \"\"\"\n    logging.info(\"Initializing the Dependencies Tool Listener.\")\n\n    self.worker_id = \"my_id\"  # TODO get from Server\n\n    signal.signal(signal.SIGINT, self._signal_teardown_handler)\n    signal.signal(signal.SIGTERM, self._signal_teardown_handler)\n</code></pre>"},{"location":"autoapi/service/listener.html#service.listener.DependenciesToolListener.process_create_dependency","title":"<code>process_create_dependency(bundle_name)</code>","text":"<p>Calls full creation dependency package process</p> Expects env vars <p>AYON_SERVER_URL AYON_API_KEY</p> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>for which bundle dependency packages should be created</p> required <p>Returns:</p> Type Description <code>str</code> <p>created package name</p> Source code in <code>service/listener.py</code> <pre><code>def process_create_dependency(self, bundle_name):\n    \"\"\"Calls full creation dependency package process\n\n    Expects env vars:\n        AYON_SERVER_URL\n        AYON_API_KEY\n\n    Args:\n        bundle_name (str): for which bundle dependency packages should be\n            created\n\n    Returns:\n        (str): created package name\n    \"\"\"\n    return create_package(bundle_name)\n</code></pre>"},{"location":"autoapi/service/listener.html#service.listener.DependenciesToolListener.start_listening","title":"<code>start_listening()</code>","text":"<p>Main loop querying the AYON event loop</p> Source code in <code>service/listener.py</code> <pre><code>def start_listening(self):\n    \"\"\" Main loop querying the AYON event loop\n    \"\"\"\n    logging.info(\"Start listening for Ayon Events...\")\n\n    platform_name = platform.system().lower()\n    target_topic = f\"dependencies.creating_package.{platform_name}\"\n\n    while True:\n        event = ayon_api.enroll_event_job(\n            SOURCE_TOPIC,\n            target_topic,\n            self.worker_id,\n            \"Creating dependency package\",\n            # Creation of dependency packages is not sequential process\n            sequential=False,\n        )\n        if not event:\n            time.sleep(2)\n            continue\n\n        src_job = ayon_api.get_event(event[\"dependsOn\"])\n        bundle_name = src_job[\"summary\"][\"name\"]\n        try:\n            package_name = self.process_create_dependency(bundle_name)\n            description = f\"{package_name} created\"\n            status = \"finished\"\n        except Exception as e:\n            status = \"finished\"\n            description = f\"Creation of package for {bundle_name} failed\\n{str(e)}\"  # noqa\n            log_traceback(e)\n\n        ayon_api.update_event(\n            event[\"id\"],\n            sender=self.worker_id,\n            status=status,\n            description=description,\n        )\n</code></pre>"}]}